import unittest
import random

from colorama import Fore
import batchTaskAllocator as bta
import time
import itertools


def main():
    numRounds = 3 # Number of rounds to be run
    numTasks = 4 # Number of tasks to be assigned per round
    numIterations = 6 # Number of conversation iterations per round
    add_test_methods(numRounds, numTasks, numIterations)


class TestAgent(unittest.TestCase):

    def getOptimalAllocation(self,tasks):
        optimalSolution = []
        bestPSRSum = 0
        n = len(tasks)
        half_n = n // 2

        # Ensure there are an even number of tasks
        if n % 2 != 0:
            raise ValueError("The number of tasks must be even to form two equal groups.")
        
        # Generate all combinations of half2_n tasks
        all_combinations = itertools.combinations(tasks, half_n)
                
        for comb in all_combinations:
            group1 = comb
            group2 = tuple(task for task in tasks if task not in group1)
            
            # Calculate the sum of the first PSR for group1 and the second PSR for group2
            sum1 = sum(task[1] for task in group1)
            sum2 = sum(task[2] for task in group2)
            PSR_Sum = sum1 + sum2

            if PSR_Sum > bestPSRSum:
                bestPSRSum = PSR_Sum
                optimalSolution = [group1, group2]

        return optimalSolution[0], optimalSolution[1], bestPSRSum
    
    def calculatePSR(self, agent1Tasks, agent2Tasks):
        PSR1 = sum(task[1] for task in agent1Tasks)
        PSR2 = sum(task[2] for task in agent2Tasks)
        return PSR1 + PSR2

    def hasOptimalAllocation(self, agent1Tasks, agent2Tasks, bestPSR):
        currPSR = self.calculatePSR(agent1Tasks, agent2Tasks)
        return currPSR >= bestPSR

    def setUp(self, numTasks):
        self.fileName = "log.txt"
        self.numTasks = numTasks  # number of tasks to be assigned
        with open(self.fileName, "w") as f:
            f.write("")  # clear file
            f.close()

    def run_round(self, round_num, numRounds, numIterations):
        allocationErrorFound = False

        with open(self.fileName, "a") as f:
            f.write(("~" * 25) + f"  ROUND {round_num} OF {numRounds}  " + ("~" * 25) + "\n")
            f.close()
        print("\n" + ("~" * 25) + f"  ROUND {round_num} OF {numRounds}  " + ("~" * 25) + "\n")

        # Generate random tasks and PSRs
        agent1 = bta.Agent("Agent 1")
        agent2 = bta.Agent("Agent 2")
        tasks = []  # formatted as [('Task X', PSR1, PSR2), ...]
        for i in range(self.numTasks):  # Generate random tasks
            task = f"Task {i+1}"
            PSR1 = round(random.uniform(0, 1), 1) # Generate random PSRs between 0 and 1, rounded to 1 decimal place
            PSR2 = round(random.uniform(0, 1), 1)
            tasks.append((task, PSR1, PSR2))

        domain = bta.Domain(agent1, agent2, tasks)
        domain.assignTasks(numIterations)
        agent1Tasks = domain.agent1.assignedTasks  # formatted as [('Task X', PSR1, PSR2), ...]
        agent2Tasks = domain.agent2.assignedTasks
        domain.printTasks()

        # bta.logMemoryBuffer(self.fileName, agent1, agent2)  # Log memory buffers
        f = open(self.fileName, "a")
        f.write("\nTasks for this round:\n")
        for task in tasks:
            f.write(f"- {task}\n")
        f.close()
        bta.logAssignedTasks(self.fileName, agent1, agent2)  # Log assigned tasks

        f = open(self.fileName, "a")
        optimalAllocation1, optimalAllocation2, bestPSR = self.getOptimalAllocation(tasks)
        hasOptimalAllocation = self.hasOptimalAllocation(agent1Tasks, agent2Tasks, bestPSR)
        if not hasOptimalAllocation:
            allocationErrorFound = True
            f.write("\nBAD TASK ALLOCATION: The tasks are not optimally allocated.\n")
            f.write("\nOptimal Allocation:\n")
            f.write(f"Agent 1: {optimalAllocation1}\n")
            f.write(f"Agent 2: {optimalAllocation2}\n")
            print(f"\n{Fore.RED}BAD TASK ALLOCATION: The tasks are not optimally allocated.")
            print("\nOptimal Allocation:")
            print(f"Agent 1: {optimalAllocation1}")
            print(f"Agent 2: {optimalAllocation2} {Fore.RESET}")
        f.write(f"\nNumber of conversation iterations: {domain.numConversationIterations}")
        f.write(f"\nNumber of tokens generated by {agent1.name}: {agent1.numTokensGenerated}")
        f.write(f"\nNumber of tokens generated by {agent2.name}: {agent2.numTokensGenerated}\n")
        f.close()
        
        return allocationErrorFound
    
def format_seconds(seconds):
    # Ensure seconds is an integer
    total_seconds = int(seconds)
    
    # Calculate hours, minutes, and remaining seconds
    hours = total_seconds // 3600
    minutes = (total_seconds % 3600) // 60
    remaining_seconds = total_seconds % 60
    
    # Format into "hh:mm:ss" with zero-padding
    formatted_time = f"{hours:02}:{minutes:02}:{remaining_seconds:02}"
    
    return formatted_time

def add_test_methods(numRounds, numTasks, numIterations):
    numAllocationErrors = 0
    ta = TestAgent()
    ta.setUp(numTasks)
    totalTime = 0
    for i in range(numRounds):
        startTime = time.time()
        allocationErrorFound = ta.run_round(i+1, numRounds, numIterations)
        endTime = time.time()
        duration = endTime - startTime
        totalTime += duration
        numAllocationErrors += 1 if allocationErrorFound else 0
        with open (ta.fileName, "a") as f:
            f.write(f"Round {i+1} Duration: Completed in {format_seconds(duration)}\n\n")
            f.close()

    with open(ta.fileName, "a") as f:
        f.write(("=" * 25) + f"  TOTAL  " + ("=" * 25) + "\n")
        f.write(f"\nTotal Allocation errors: {numAllocationErrors} of {numRounds} rounds had an Allocation Error")
        f.write(f"\nTotal Time: {format_seconds(totalTime)}")
        f.write(f"\nAverage Time per Round: {format_seconds(totalTime/numRounds)}\n")
        f.close()

main()