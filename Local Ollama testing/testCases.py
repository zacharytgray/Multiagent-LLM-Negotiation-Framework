import unittest
import random
import batchTaskAllocator as bta
import time

class TestAgent(unittest.TestCase):

    def getOptimalAllocation(self, tasks):
        n = len(tasks) // 2
        dp = [[-1 for _ in range(n+1)] for _ in range(len(tasks)+1)]
        backtrack = [[None for _ in range(n+1)] for _ in range(len(tasks)+1)] #backtrack[i][j] helps to reconstruct the solution. It stores a tuple indicating the previous state and which agent took the task.

        dp[0][0] = 0 #dp[i][j] keeps the maximum skill sum we can achieve for agent 1 considering the first i tasks and allocating j tasks to agent 1.


        for i in range(1, len(tasks)+1): # Loop through each task and update the dp and backtrack tables.
            for j in range(n+1):
                if j > 0 and dp[i-1][j-1] != -1: #If adding the current task to agent 1 improves the skill sum, update the dp table accordingly.
                    val = dp[i-1][j-1] + tasks[i-1][1]
                    if val > dp[i][j]:
                        dp[i][j] = val
                        backtrack[i][j] = (i-1, j-1, True)
                if dp[i-1][j] != -1: # Similarly, check if adding the current task to agent 2 improves the skill sum.
                    val = dp[i-1][j] + tasks[i-1][2]
                    if val > dp[i][j]:
                        dp[i][j] = val
                        backtrack[i][j] = (i-1, j, False)

        agent1_tasks, agent2_tasks = [], []
        i, j = len(tasks), n

        while i > 0: # Start from the last task and backtrack to determine which tasks were allocated to each agent.
            if backtrack[i][j][2]:
                agent1_tasks.append(tasks[backtrack[i][j][0]])
                i, j = backtrack[i][j][0], backtrack[i][j][1]
            else:
                agent2_tasks.append(tasks[backtrack[i][j][0]])
                i = backtrack[i][j][0]

        return agent1_tasks, agent2_tasks # After backtracking, we get the tasks allocated to each agent.
                  
    def hasOptimalAllocation(self, agent1Tasks, agent2Tasks, optimalAgent1Tasks, optimalAgent2Tasks):
        for task in agent1Tasks:
            if task not in optimalAgent1Tasks:
                return False
        for task in agent2Tasks:
            if task not in optimalAgent2Tasks:
                return False
        return True

    def setUp(self, numTasks):
        self.fileName = "log.txt"
        self.numTasks = numTasks  # number of tasks to be assigned
        with open(self.fileName, "w") as f:
            f.write("")  # clear file
            f.close()

    def run_round(self, round_num, numRounds):
        allocationErrorFound = False

        with open(self.fileName, "a") as f:
            f.write(("~" * 25) + f"  ROUND {round_num} OF {numRounds}  " + ("~" * 25) + "\n")
            f.close()
        print("\n" + ("~" * 25) + f"  ROUND {round_num} OF {numRounds}  " + ("~" * 25) + "\n")

        # Generate random tasks and skills
        agent1 = bta.Agent("Agent 1")
        agent2 = bta.Agent("Agent 2")
        tasks = []  # formatted as [('Task X', skill1, skill2), ...]
        for i in range(self.numTasks):  # Generate random tasks
            task = f"Task {i+1}"
            skill1 = random.randint(1, 10)
            skill2 = random.randint(1, 10)
            tasks.append((task, skill1, skill2))


        domain = bta.Domain(agent1, agent2, tasks)
        domain.assignTasks()
        agent1Tasks = domain.agent1.assignedTasks  # formatted as [('Task X', skill1, skill2), ...]
        agent2Tasks = domain.agent2.assignedTasks
        domain.printTasks()

        # bta.logMemoryBuffer(self.fileName, agent1, agent2)  # Log memory buffers
        f = open(self.fileName, "a")
        f.write("\nTasks for this round:\n")
        for task in tasks:
            f.write(f"- {task}\n")
        f.close()
        bta.logAssignedTasks(self.fileName, agent1, agent2)  # Log assigned tasks

        f = open(self.fileName, "a")
        optimalAllocation = self.getOptimalAllocation(tasks)
        hasOptimalAllocation = self.hasOptimalAllocation(agent1Tasks, agent2Tasks, optimalAllocation[0], optimalAllocation[1])
        if not hasOptimalAllocation:
            allocationErrorFound = True
            f.write("\nBAD TASK ALLOCATION: The tasks are not optimally allocated.\n")
            f.write("\nOptimal Allocation:\n")
            f.write(f"Agent 1: {optimalAllocation[0]}\n")
            f.write(f"Agent 2: {optimalAllocation[1]}\n")
        f.write(f"\nNumber of conversation iterations: {domain.numConversationIterations}")
        f.write(f"\nNumber of tokens generated by {agent1.name}: {agent1.numTokensGenerated}")
        f.write(f"\nNumber of tokens generated by {agent2.name}: {agent2.numTokensGenerated}\n")
        f.close()
        return allocationErrorFound
    
def format_seconds(seconds):
    # Ensure seconds is an integer
    total_seconds = int(seconds)
    
    # Calculate hours, minutes, and remaining seconds
    hours = total_seconds // 3600
    minutes = (total_seconds % 3600) // 60
    remaining_seconds = total_seconds % 60
    
    # Format into "hh:mm:ss" with zero-padding
    formatted_time = f"{hours:02}:{minutes:02}:{remaining_seconds:02}"
    
    return formatted_time

def add_test_methods():
    numRounds = 10
    numAllocationErrors = 0
    # totalSUSScore = 0
    ta = TestAgent()
    ta.setUp(numTasks = 6)
    totalTime = 0
    for i in range(numRounds):
        startTime = time.time()
        allocationErrorFound = ta.run_round(i+1, numRounds)
        # totalSUSScore += SUS
        endTime = time.time()
        duration = endTime - startTime
        totalTime += duration
        numAllocationErrors += 1 if allocationErrorFound else 0
        with open (ta.fileName, "a") as f:
            f.write(f"Round {i+1} Duration: Completed in {format_seconds(duration)}\n\n")
            f.close()

    with open(ta.fileName, "a") as f:
        f.write(("=" * 25) + f"  TOTAL  " + ("=" * 25) + "\n")
        f.write(f"\nTotal Allocation errors: {numAllocationErrors} of {numRounds} rounds had an Allocation Error")
        # f.write(f"\nAverage SUS: {totalSUSScore / numRounds}%")
        f.write(f"\nTotal Time: {format_seconds(totalTime)}")
        f.write(f"\nAverage Time per Round: {format_seconds(totalTime/numRounds)}\n")
        f.close()

def main():
    add_test_methods()

if __name__ == '__main__':
    main()