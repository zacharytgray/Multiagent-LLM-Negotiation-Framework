import unittest
import random
import batchTaskAllocator as bta
import time

class TestAgent(unittest.TestCase):

    def setUp(self):
        self.fileName = "log.txt"
        self.numTasks = 4  # number of tasks to be assigned
        with open(self.fileName, "w") as f:
            f.write("")  # clear file
            f.close()

    def run_round(self, round_num, numRounds):
        workloadErrorFound = False
        assignMentErrorFound = False

        with open(self.fileName, "a") as f:
            f.write(("~" * 25) + f"  ROUND {round_num} OF {numRounds}  " + ("~" * 25) + "\n")
            f.close()
        print("\n" + ("~" * 25) + f"  ROUND {round_num} OF {numRounds}  " + ("~" * 25) + "\n")

        # Generate random tasks and skills
        agent1 = bta.Agent("Agent 1")
        agent2 = bta.Agent("Agent 2")
        tasks = []  # formatted as [('Task X', skill1, skill2), ...]
        for i in range(self.numTasks):  # Generate random tasks
            task = f"Task {i+1}"
            slicePoint = random.randint(1, 9)
            skill1 = slicePoint
            skill2 = 10 - slicePoint
            tasks.append((task, skill1, skill2))

        domain = bta.Domain(agent1, agent2, tasks)
        domain.assignTasks()
        agent1Tasks = domain.agent1.assignedTasks  # formatted as [('Task X', skill1, skill2), ...]
        agent2Tasks = domain.agent2.assignedTasks
        domain.printTasks()

        # bta.logMemoryBuffer(self.fileName, agent1, agent2)  # Log memory buffers
        f = open(self.fileName, "a")
        f.write("\nTasks for this round:\n")
        for task in tasks:
            f.write(f"- {task}\n")
        f.close()
        bta.logAssignedTasks(self.fileName, agent1, agent2)  # Log assigned tasks

        # Check if tasks are assigned correctly
        f = open(self.fileName, "a")
        for task, skill1, skill2 in tasks:
            if skill1 != 5 and skill2 != 5: # Ignore tasks with skill 5 because of ambiguous assignment
                if skill1 > skill2: # Task should be assigned to agent 1
                    try:
                        self.assertIn((task, skill1, skill2), agent1Tasks)
                    except AssertionError as e: # Task not found in agent1's assigned tasks
                        f.write(f"\nASSIGNMENT ERROR: {task} is not in {agent1.name}'s assigned tasks\n")
                        assignMentErrorFound = True
                else:
                    try: 
                        self.assertIn((task, skill1, skill2), agent2Tasks)
                    except AssertionError as e: # Task not found in agent2's assigned tasks
                        f.write(f"\nASSIGNMENT ERROR: {task} is not in {agent2.name}'s assigned tasks\n")
                        assignMentErrorFound = True

        # Check if workload is balanced
        numTasks1 = len(agent1Tasks)
        numTasks2 = len(agent2Tasks)
        try:
            self.assertAlmostEqual(numTasks1, numTasks2, delta=2)  # Allow a small delta for balance
        except AssertionError as e:
            f.write(f"\nWORKLOAD ERROR: {e}\n")
            workloadErrorFound = True

        f.write(f"\nNumber of conversation iterations: {domain.numConversationIterations}")
        f.write(f"\nNumber of tokens generated by {agent1.name}: {agent1.numTokensGenerated}")
        f.write(f"\nNumber of tokens generated by {agent2.name}: {agent2.numTokensGenerated}\n")
        f.close()
        return workloadErrorFound, assignMentErrorFound
    
def format_seconds(seconds):
    # Ensure seconds is an integer
    total_seconds = int(seconds)
    
    # Calculate hours, minutes, and remaining seconds
    hours = total_seconds // 3600
    minutes = (total_seconds % 3600) // 60
    remaining_seconds = total_seconds % 60
    
    # Format into "hh:mm:ss" with zero-padding
    formatted_time = f"{hours:02}:{minutes:02}:{remaining_seconds:02}"
    
    return formatted_time

def add_test_methods():
    numRounds = 25
    numWorkloadErrors = 0
    numAssignmentErrors = 0
    ta = TestAgent()
    ta.setUp()
    totalTime = 0
    for i in range(numRounds):
        startTime = time.time()
        workloadErrorFound, assignmentErrorFound = ta.run_round(i+1, numRounds)
        endTime = time.time()
        duration = endTime - startTime
        totalTime += duration
        numWorkloadErrors += 1 if workloadErrorFound else 0
        numAssignmentErrors += 1 if assignmentErrorFound else 0
        with open (ta.fileName, "a") as f:
            f.write(f"Round {i+1} Duration: Completed in {format_seconds(duration)}\n\n")
            f.close()

    with open(ta.fileName, "a") as f:
        f.write(("=" * 25) + f"  TOTAL  " + ("=" * 25) + "\n")
        f.write(f"\nTotal Workload errors: {numWorkloadErrors} of {numRounds} rounds had a Workload Error")
        f.write(f"\nTotal Assignment errors: {numAssignmentErrors} of {numRounds} rounds had an Assignment Error")
        f.write(f"\nTotal Time: {format_seconds(totalTime)}")
        f.write(f"\nAverage Time per Round: {format_seconds(totalTime/numRounds)}\n")
        f.close()

def main():
    add_test_methods()

if __name__ == '__main__':
    main()